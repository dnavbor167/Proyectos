/**
 * The `node:test` module facilitates the creation of JavaScript tests.
 * To access it:
 *
 * ```js
 * import test from 'node:test';
 * ```
 *
 * This module is only available under the `node:` scheme. The following will not
 * work:
 *
 * ```js
 * import test from 'node:test';
 * ```
 *
 * Tests created via the `test` module consist of a single function that is
 * processed in one of three ways:
 *
 * 1. A synchronous function that is considered failing if it throws an exception,
 * and is considered passing otherwise.
 * 2. A function that returns a `Promise` that is considered failing if the `Promise` rejects, and is considered passing if the `Promise` fulfills.
 * 3. A function that receives a callback function. If the callback receives any
 * truthy value as its first argument, the test is considered failing. If a
 * falsy value is passed as the first argument to the callback, the test is
 * considered passing. If the test function receives a callback function and
 * also returns a `Promise`, the test will fail.
 *
 * The following example illustrates how tests are written using the `test` module.
 *
 * ```js
 * test('synchronous passing test', (t) => {
 *   // This test passes because it does not throw an exception.
 *   assert.strictEqual(1, 1);
 * });
 *
 * test('synchronous failing test', (t) => {
 *   // This test fails because it throws an exception.
 *   assert.strictEqual(1, 2);
 * });
 *
 * test('asynchronous passing test', async (t) => {
 *   // This test passes because the Promise returned by the async
 *   // function is settled and not rejected.
 *   assert.strictEqual(1, 1);
 * });
 *
 * test('asynchronous failing test', async (t) => {
 *   // This test fails because the Promise returned by the async
 *   // function is rejected.
 *   assert.strictEqual(1, 2);
 * });
 *
 * test('failing test using Promises', (t) => {
 *   // Promises can be used directly as well.
 *   return new Promise((resolve, reject) => {
 *     setImmediate(() => {
 *       reject(new Error('this will cause the test to fail'));
 *     });
 *   });
 * });
 *
 * test('callback passing test', (t, done) => {
 *   // done() is the callback function. When the setImmediate() runs, it invokes
 *   // done() with no arguments.
 *   setImmediate(done);
 * });
 *
 * test('callback failing test', (t, done) => {
 *   // When the setImmediate() runs, done() is invoked with an Error object and
 *   // the test fails.
 *   setImmediate(() => {
 *     done(new Error('callback failure'));
 *   });
 * });
 * ```
 *
 * If any tests fail, the process exit code is set to `1`.
 * @since v18.0.0, v16.17.0
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/test.js)
 */
declare module "node:test" {
    import { Readable } from "node:stream";
    /**
     * **Note:** `shard` is used to horizontally parallelize test running across
     * machines or processes, ideal for large-scale executions across varied
     * environments. It's incompatible with `watch` mode, tailored for rapid
     * code iteration by automatically rerunning tests on file changes.
     *
     * ```js
     * import { tap } from 'node:test/reporters';
     * import { run } from 'node:test';
     * import process from 'node:process';
     * import path from 'node:path';
     *
     * run({ files: [path.resolve('./tests/test.js')] })
     *   .compose(tap)
     *   .pipe(process.stdout);
     * ```
     * @since v18.9.0, v16.19.0
     * @param options Configuration options for running tests.
     */
    function run(options?: RunOptions): TestsStream;
    /**
     * The `test()` function is the value imported from the `test` module. Each
     * invocation of this function results in reporting the test to the `TestsStream`.
     *
     * The `TestContext` object passed to the `fn` argument can be used to perform
     * actions related to the current test. Examples include skipping the test, adding
     * additional diagnostic information, or creating subtests.
     *
     * `test()` returns a `Promise` that fulfills once the test completes.
     * if `test()` is called within a suite, it fulfills immediately.
     * The return value can usually be discarded for top level tests.
     * However, the return value from subtests should be used to prevent the parent
     * test from finishing first and cancelling the subtest
     * as shown in the following example.
     *
     * ```js
     * test('top level test', async (t) => {
     *   // The setTimeout() in the following subtest would cause it to outlive its
     *   // parent test if 'await' is removed on the next line. Once the parent test
     *   // completes, it will cancel any outstanding subtests.
     *   await t.test('longer running subtest', async (t) => {
     *     return new Promise((resolve, reject) => {
     *       setTimeout(resolve, 1000);
     *     });
     *   });
     * });
     * ```
     *
     * The `timeout` option can be used to fail the test if it takes longer than `timeout` milliseconds to complete. However, it is not a reliable mechanism for
     * canceling tests because a running test might block the application thread and
     * thus prevent the scheduled cancellation.
     * @since v18.0.0, v16.17.0
     * @param name The name of the test, which is displayed when reporting test results.
     * Defaults to the `name` property of `fn`, or `'<anonymous>'` if `fn` does not have a name.
     * @param options Configuration options for the test.
     * @param fn The function under test. The first argument to this function is a {@link TestContext} object.
     * If the test uses callbacks, the callback function is passed as the second argument.
     * @return Fulfilled with `undefined` once the test completes, or immediately if the test runs within a suite.
     */
    function test(name?: string, fn?: TestFn): Promise<void>;
    function test(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
    function test(options?: TestOptions, fn?: TestFn): Promise<void>;
    function test(fn?: TestFn): Promise<void>;
    namespace test {
        export {
            after,
            afterEach,
            before,
            beforeEach,
            describe,
            it,
            mock,
            only,
            run,
            skip,
            snapshot,
            suite,
            test,
            todo,
        };
    }
    /**
     * The `suite()` function is imported from the `node:test` module.
     * @param name The name of the suite, which is displayed when reporting test results.
     * Defaults to the `name` property of `fn`, or `'<anonymous>'` if `fn` does not have a name.
     * @param options Configuration options for the suite. This supports the same options as {@link test}.
     * @param fn The suite function declaring nested tests and suites. The first argument to this function is a {@link SuiteContext} object.
     * @return Immediately fulfilled with `undefined`.
     * @since v20.13.0
     */
    function suite(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
    function suite(name?: string, fn?: SuiteFn): Promise<void>;
    function suite(options?: TestOptions, fn?: SuiteFn): Promise<void>;
    function suite(fn?: SuiteFn): Promise<void>;
    namespace suite {
        /**
         * Shorthand for skipping a suite. This is the same as calling {@link suite} with `options.skip` set to `true`.
         * @since v20.13.0
         */
        function skip(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function skip(name?: string, fn?: SuiteFn): Promise<void>;
        function skip(options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function skip(fn?: SuiteFn): Promise<void>;
        /**
         * Shorthand for marking a suite as `TODO`. This is the same as calling {@link suite} with `options.todo` set to `true`.
         * @since v20.13.0
         */
        function todo(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function todo(name?: string, fn?: SuiteFn): Promise<void>;
        function todo(options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function todo(fn?: SuiteFn): Promise<void>;
        /**
         * Shorthand for marking a suite as `only`. This is the same as calling {@link suite} with `options.only` set to `true`.
         * @since v20.13.0
         */
        function only(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function only(name?: string, fn?: SuiteFn): Promise<void>;
        function only(options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function only(fn?: SuiteFn): Promise<void>;
    }
    /**
     * Alias for {@link suite}.
     *
     * The `describe()` function is imported from the `node:test` module.
     */
    function describe(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
    function describe(name?: string, fn?: SuiteFn): Promise<void>;
    function describe(options?: TestOptions, fn?: SuiteFn): Promise<void>;
    function describe(fn?: SuiteFn): Promise<void>;
    namespace describe {
        /**
         * Shorthand for skipping a suite. This is the same as calling {@link describe} with `options.skip` set to `true`.
         * @since v18.15.0
         */
        function skip(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function skip(name?: string, fn?: SuiteFn): Promise<void>;
        function skip(options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function skip(fn?: SuiteFn): Promise<void>;
        /**
         * Shorthand for marking a suite as `TODO`. This is the same as calling {@link describe} with `options.todo` set to `true`.
         * @since v18.15.0
         */
        function todo(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function todo(name?: string, fn?: SuiteFn): Promise<void>;
        function todo(options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function todo(fn?: SuiteFn): Promise<void>;
        /**
         * Shorthand for marking a suite as `only`. This is the same as calling {@link describe} with `options.only` set to `true`.
         * @since v18.15.0
         */
        function only(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function only(name?: string, fn?: SuiteFn): Promise<void>;
        function only(options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function only(fn?: SuiteFn): Promise<void>;
    }
    /**
     * Alias for {@link test}.
     *
     * The `it()` function is imported from the `node:test` module.
     * @since v18.6.0, v16.17.0
     */
    function it(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
    function it(name?: string, fn?: TestFn): Promise<void>;
    function it(options?: TestOptions, fn?: TestFn): Promise<void>;
    function it(fn?: TestFn): Promise<void>;
    namespace it {
        /**
         * Shorthand for skipping a test. This is the same as calling {@link it} with `options.skip` set to `true`.
         */
        function skip(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
        function skip(name?: string, fn?: TestFn): Promise<void>;
        function skip(options?: TestOptions, fn?: TestFn): Promise<void>;
        function skip(fn?: TestFn): Promise<void>;
        /**
         * Shorthand for marking a test as `TODO`. This is the same as calling {@link it} with `options.todo` set to `true`.
         */
        function todo(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
        function todo(name?: string, fn?: TestFn): Promise<void>;
        function todo(options?: TestOptions, fn?: TestFn): Promise<void>;
        function todo(fn?: TestFn): Promise<void>;
        /**
         * Shorthand for marking a test as `only`. This is the same as calling {@link it} with `options.only` set to `true`.
         * @since v18.15.0
         */
        function only(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
        function only(name?: string, fn?: TestFn): Promise<void>;
        function only(options?: TestOptions, fn?: TestFn): Promise<void>;
        function only(fn?: TestFn): Promise<void>;
    }
    /**
     * Shorthand for skipping a test. This is the same as calling {@link test} with `options.skip` set to `true`.
     * @since v20.2.0
     */
    function skip(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
    function skip(name?: string, fn?: TestFn): Promise<void>;
    function skip(options?: TestOptions, fn?: TestFn): Promise<void>;
    function skip(fn?: TestFn): Promise<void>;
    /**
     * Shorthand for marking a test as `TODO`. This is the same as calling {@link test} with `options.todo` set to `true`.
     * @since v20.2.0
     */
    function todo(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
    function todo(name?: string, fn?: TestFn): Promise<void>;
    function todo(options?: TestOptions, fn?: TestFn): Promise<void>;
    function todo(fn?: TestFn): Promise<void>;
    /**
     * Shorthand for marking a test as `only`. This is the same as calling {@link test} with `options.only` set to `true`.
     * @since v20.2.0
     */
    function only(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
    function only(name?: string, fn?: TestFn): Promise<void>;
    function only(options?: TestOptions, fn?: TestFn): Promise<void>;
    function only(fn?: TestFn): Promise<void>;
    /**
     * The type of a function passed to {@link test}. The first argument to this function is a {@link TestContext} object.
     * If the test uses callbacks, the callback function is passed as the second argument.
     */
    type TestFn = (t: TestContext, done: (result?: any) => void) => void | Promise<void>;
    /**
     * The type of a suite test function. The argument to this function is a {@link SuiteContext} object.
     */
    type SuiteFn = (s: SuiteContext) => void | Promise<void>;
    interface TestShard {
        /**
         * A positive integer between 1 and `total` that specifies the index of the shard to run.
         */
        index: number;
        /**
         * A positive integer that specifies the total number of shards to split the test files to.
         */
        total: number;
    }
    interface RunOptions {
        /**
         * If a number is provided, then that many test processes would run in parallel, where each process corresponds to one test file.
         * If `true`, it would run `os.availableParallelism() - 1` test files in parallel. If `false`, it would only run one test file at a time.
         * @default false
         */
        concurrency?: number | boolean | undefined;
        /**
         * An array containing the list of files to run. If omitted, files are run according to the
         * [test runner execution model](https://nodejs.org/docs/latest-v22.x/api/test.html#test-runner-execution-model).
         */
        files?: readonly string[] | undefined;
        /**
         * Configures the test runner to exit the process once all known
         * tests have finished executing even if the event loop would
         * otherwise remain active.
         * @default false
         */
        forceExit?: boolean | undefined;
        /**
         * An array containing the list of glob patterns to match test files.
         * This option cannot be used together with `files`. If omitted, files are run according to the
         * [test runner execution model](https://nodejs.org/docs/latest-v22.x/api/test.html#test-runner-execution-model).
         * @since v22.6.0
         */
        globPatterns?: readonly string[] | undefined;
        /**
         * Sets inspector port of test child process.
         * This can be a number, or a function that takes no arguments and returns a
         * number. If a nullish value is provided, each process gets its own port,
         * incremented from the primary's `process.debugPort`. This option is ignored
         * if the `isolation` option is set to `'none'` as no child processes are
         * spawned.
         * @default undefined
         */
        inspectPort?: number | (() => number) | undefined;
        /**
         * Configures the type of test isolation. If set to
         * `'process'`, each test file is run in a separate child process. If set to
         * `'none'`, all test files run in the current process.
         * @default 'process'
         * @since v22.8.0
         */
        isolation?: "process" | "none" | undefined;
        /**
         * If truthy, the test context will only run tests that have the `only` option set
         */
        only?: boolean | undefined;
        /**
         * A function that accepts the `TestsStream` instance and can be used to setup listeners before any tests are run.
         * @default undefined
         */
        setup?: ((reporter: TestsStream) => void | Promise<void>) | undefined;
        /**
         * An array of CLI flags to pass to the `node` executable when
         * spawning the subprocesses. This option has no effect when `isolation` is `'none`'.
         * @since v22.10.0
         * @default []
         */
        execArgv?: readonly string[] | undefined;
        /**
         * An array of CLI flags to pass to each test file when spawning the
         * subprocesses. This option has no effect when `isolation` is `'none'`.
         * @since v22.10.0
         * @default []
         */
        argv?: readonly string[] | undefined;
        /**
         * Allows aborting an in-progress test execution.
         */
        signal?: AbortSignal | undefined;
        /**
         * If provided, only run tests whose name matches the provided pattern.
         * Strings are interpreted as JavaScript regular expressions.
         * @default undefined
         */
        testNamePatterns?: string | RegExp | ReadonlyArray<string | RegExp> | undefined;
        /**
         * A String, RegExp or a RegExp Array, that can be used to exclude running tests whose
         * name matches the provided pattern. Test name patterns are interpreted as JavaScript
         * regular expressions. For each test that is executed, any corresponding test hooks,
         * such as `beforeEach()`, are also run.
         * @default undefined
         * @since v22.1.0
         */
        testSkipPatterns?: string | RegExp | ReadonlyArray<string | RegExp> | undefined;
        /**
         * The number of milliseconds after which the test execution will fail.
         * If unspecified, subtests inherit this value from their parent.
         * @default Infinity
         */
        timeout?: number | undefined;
        /**
         * Whether to run in watch mode or not.
         * @default false
         */
        watch?: boolean | undefined;
        /**
         * Running tests in a specific shard.
         * @default undefined
         */
        shard?: TestShard | undefined;
        /**
         * enable [code coverage](https://nodejs.org/docs/latest-v22.x/api/test.html#collecting-code-coverage) collection.
         * @since v22.10.0
         * @default false
         */
        coverage?: boolean | undefined;
        /**
         * Excludes specific files from code coverage
         * using a glob pattern, which can match both absolute and relative file paths.
         * This property is only applicable when `coverage` was set to `true`.
         * If both `coverageExcludeGlobs` and `coverageIncludeGlobs` are provided,
         * files must meet **both** criteria to be included in the coverage report.
         * @since v22.10.0
         * @default undefined
         */
        coverageExcludeGlobs?: string | readonly string[] | undefined;
        /**
         * Includes specific files in code coverage
         * using a glob pattern, which can match both absolute and relative file paths.
         * This property is only applicable when `coverage` was set to `true`.
         * If both `coverageExcludeGlobs` and `coverageIncludeGlobs` are provided,
         * files must meet **both** criteria to be included in the coverage report.
         * @since v22.10.0
         * @default undefined
         */
        coverageIncludeGlobs?: string | readonly string[] | undefined;
        /**
         * Require a minimum percent of covered lines. If code
         * coverage does not reach the threshold specified, the process will exit with code `1`.
         * @since v22.10.0
         * @default 0
         */
        lineCoverage?: number | undefined;
        /**
         * Require a minimum percent of covered branches. If code
         * coverage does not reach the threshold specified, the process will exit with code `1`.
         * @since v22.10.0
         * @default 0
         */
        branchCoverage?: number | undefined;
        /**
         * Require a minimum percent of covered functions. If code
         * coverage does not reach the threshold specified, the process will exit with code `1`.
         * @since v22.10.0
         * @default 0
         */
        functionCoverage?: number | undefined;
    }
    /**
     * A successful call to `run()` will return a new `TestsStream` object, streaming a series of events representing the execution of the tests.
     *
     * Some of the events are guaranteed to be emitted in the same order as the tests are defined, while others are emitted in the order that the tests execute.
     * @since v18.9.0, v16.19.0
     */
    class TestsStream extends Readable implements NodeJS.ReadableStream {
        addListener(event: "test:coverage", listener: (data: TestCoverage) => void): this;
        addListener(event: "test:complete", listener: (data: TestComplete) => void): this;
        addListener(event: "test:dequeue", listener: (data: TestDequeue) => void): this;
        addListener(event: "test:diagnostic", listener: (data: DiagnosticData) => void): this;
        addListener(event: "test:enqueue", listener: (data: TestEnqueue) => void): this;
        addListener(event: "test:fail", listener: (data: TestFail) => void): this;
        addListener(event: "test:pass", listener: (data: TestPass) => void): this;
        addListener(event: "test:plan", listener: (data: TestPlan) => void): this;
        addListener(event: "test:start", listener: (data: TestStart) => void): this;
        addListener(event: "test:stderr", listener: (data: TestStderr) => void): this;
        addListener(event: "test:stdout", listener: (data: TestStdout) => void): this;
        addListener(event: "test:summary", listener: (data: TestSummary) => void): this;
        addListener(event: "test:watch:drained", listener: () => void): this;
        addListener(event: string, listener: (...args: any[]) => void): this;
        emit(event: "test:coverage", data: TestCoverage): boolean;
        emit(event: "test:complete", data: TestComplete): boolean;
        emit(event: "test:dequeue", data: TestDequeue): boolean;
        emit(event: "test:diagnostic", data: DiagnosticData): boolean;
        emit(event: "test:enqueue", data: TestEnqueue): boolean;
        emit(event: "test:fail", data: TestFail): boolean;
        emit(event: "test:pass", data: TestPass): boolean;
        emit(event: "test:plan", data: TestPlan): boolean;
        emit(event: "test:start", data: TestStart): boolean;
        emit(event: "test:stderr", data: TestStderr): boolean;
        emit(event: "test:stdout", data: TestStdout): boolean;
        emit(event: "test:summary", data: TestSummary): boolean;
        emit(event: "test:watch:drained"): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "test:coverage", listener: (data: TestCoverage) => void): this;
        on(event: "test:complete", listener: (data: TestComplete) => void): this;
        on(event: "test:dequeue", listener: (data: TestDequeue) => void): this;
        on(event: "test:diagnostic", listener: (data: DiagnosticData) => void): this;
        on(event: "test:enqueue", listener: (data: TestEnqueue) => void): this;
        on(event: "test:fail", listener: (data: TestFail) => void): this;
        on(event: "test:pass", listener: (data: TestPass) => void): this;
        on(event: "test:plan", listener: (data: TestPlan) => void): this;
        on(event: "test:start", listener: (data: TestStart) => void): this;
        on(event: "test:stderr", listener: (data: TestStderr) => void): this;
        on(event: "test:stdout", listener: (data: TestStdout) => void): this;
        on(event: "test:summary", listener: (data: TestSummary) => void): this;
        on(event: "test:watch:drained", listener: () => void): this;
        on(event: string, listener: (...args: any[]) => void): this;
        once(event: "test:coverage", listener: (data: TestCoverage) => void): this;
        once(event: "test:complete", listener: (data: TestComplete) => void): this;
        once(event: "test:dequeue", listener: (data: TestDequeue) => void): this;
        once(event: "test:diagnostic", listener: (data: DiagnosticData) => void): this;
        once(event: "test:enqueue", listener: (data: TestEnqueue) => void): this;
        once(event: "test:fail", listener: (data: TestFail) => void): this;
        once(event: "test:pass", listener: (data: TestPass) => void): this;
        once(event: "test:plan", listener: (data: TestPlan) => void): this;
        once(event: "test:start", listener: (data: TestStart) => void): this;
        once(event: "test:stderr", listener: (data: TestStderr) => void): this;
        once(event: "test:stdout", listener: (data: TestStdout) => void): this;
        once(event: "test:summary", listener: (data: TestSummary) => void): this;
        once(event: "test:watch:drained", listener: () => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "test:coverage", listener: (data: TestCoverage) => void): this;
        prependListener(event: "test:complete", listener: (data: TestComplete) => void): this;
        prependListener(event: "test:dequeue", listener: (data: TestDequeue) => void): this;
        prependListener(event: "test:diagnostic", listener: (data: DiagnosticData) => void): this;
        prependListener(event: "test:enqueue", listener: (data: TestEnqueue) => void): this;
        prependListener(event: "test:fail", listener: (data: TestFail) => void): this;
        prependListener(event: "test:pass", listener: (data: TestPass) => void): this;
        prependListener(event: "test:plan", listener: (data: TestPlan) => void): this;
        prependListener(event: "test:start", listener: (data: TestStart) => void): this;
        prependListener(event: "test:stderr", listener: (data: TestStderr) => void): this;
        prependListener(event: "test:stdout", listener: (data: TestStdout) => void): this;
        prependListener(event: "test:summary", listener: (data: TestSummary) => void): this;
        prependListener(event: "test:watch:drained", listener: () => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "test:coverage", listener: (data: TestCoverage) => void): this;
        prependOnceListener(event: "test:complete", listener: (data: TestComplete) => void): this;
        prependOnceListener(event: "test:dequeue", listener: (data: TestDequeue) => void): this;
        prependOnceListener(event: "test:diagnostic", listener: (data: DiagnosticData) => void): this;
        prependOnceListener(event: "test:enqueue", listener: (data: TestEnqueue) => void): this;
        prependOnceListener(event: "test:fail", listener: (data: TestFail) => void): this;
        prependOnceListener(event: "test:pass", listener: (data: TestPass) => void): this;
        prependOnceListener(event: "test:plan", listener: (data: TestPlan) => void): this;
        prependOnceListener(event: "test:start", listener: (data: TestStart) => void): this;
        prependOnceListener(event: "test:stderr", listener: (data: